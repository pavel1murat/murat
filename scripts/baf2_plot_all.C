///////////////////////////////////////////////////////////////////////////////
// from here it looks that the fast component is close to 11%, not 20%
///////////////////////////////////////////////////////////////////////////////

/*
root [2] f_all->Integral(100,500)
(Double_t)9.92299436304063818e+01
root [3] f_fast->Integral(100,500)
(Double_t)1.14554964660606533e+01
*/

namespace {
  TF1* f_all;
  TF1* f_fast;
};

double  baf2_all(double *X, double* P) {
  const double npt = 49;

  double data[2*npt] = {
    166.843,0.00     ,
    176.998,0.0244137, 
    183.131,0.0807493,
    187.662,0.129029 ,
    190.328,0.154781 ,
    192.198,0.161232 ,
    195.408,0.156443 ,
    199.690,0.143628 ,
    203.171,0.125980 ,
    205.045,0.116354 ,
    207.182,0.122808 ,
    208.779,0.148548 ,
    210.639,0.187153 ,
    213.032,0.232195 ,
    214.892,0.272408 ,
    217.019,0.312623 ,
    219.692,0.314260 ,
    223.172,0.301435 ,
    226.389,0.272531 ,
    229.874,0.242022 ,
    232.826,0.205076 ,
    235.240,0.180986 ,
    238.186,0.163333 ,
    242.734,0.155343 ,
    247.546,0.158610 ,
    251.285,0.173119 ,
    254.217,0.203697 ,
    257.678,0.255181 ,
    265.123,0.395132 ,
    274.965,0.567263 ,
    284.808,0.736178 ,
    291.992,0.853618 ,
    295.716,0.921182 ,
    299.980,0.966244 ,
    304.519,0.988800 ,
    306.657,0.993647 ,
    310.673,0.976005 ,
    313.089,0.943876 ,
    318.457,0.873195 ,
    327.312,0.767180 ,
    333.489,0.677215 ,
    341.007,0.571186 ,
    351.478,0.424997 ,
    361.396,0.339894 ,
    374.255,0.258039 ,
    391.384,0.200344 ,
    411.990,0.141080 ,
    439.552,0.0674206,
    460.160,0.00       
  };

  double x, x1, x2, y1, y2, xmin, xmax, f;

  x = X[0];

  xmin = data[0];
  xmax = data[2*(npt-1)];

  if ((x < xmin) || (x >= xmax)) {
    f = 0;
  }
  else {
//-----------------------------------------------------------------------------
// interpolate
//-----------------------------------------------------------------------------
    for (int i=0; i<npt; i++) {
      x1 = data[2*i];
      x2 = data[2*i+2];
      if ((x >= x1) && (x<x2)) {
	y1 = data[2*i+1];
	y2 = data[2*i+3];
	
	f = y1+(y2-y1)/(x2-x1)*(x-x1);
	break;
      }
    }
  }

  return f;
}

double  baf2_fast(double *X, double* P) {
  const double npt = 31;

  double data[2*npt] = {
    172.995,0.0,
    177.805,0.0067375,
    181.808,0.0325038, 
    185.005,0.0711232, 
    188.472,0.101707 , 
    191.672,0.129072 , 
    192.736,0.148376 , 
    195.411,0.145189 , 
    198.089,0.130749 , 
    201.036,0.111488 , 
    205.852,0.101893 , 
    209.058,0.109966 , 
    211.459,0.129284 , 
    213.853,0.169503 , 
    215.443,0.219359 , 
    217.571,0.256359 , 
    218.631,0.286917 , 
    219.963,0.303008 , 
    222.642,0.286960 , 
    225.325,0.256442 , 
    227.742,0.219491 , 
    232.571,0.163273 , 
    239.270,0.115113 , 
    247.569,0.0814400, 
    256.668,0.0525987, 
    265.230,0.0350056, 
    274.324,0.0222414, 
    282.349,0.0126811, 
    291.175,0.0047372,
    298.394,0.0032068,
    303.208,0.0
  };

  double x, x1, x2, xmin, xmax, y1, y2, f;

  x = X[0];

  xmin = data[0];
  xmax = data[2*(npt-1)];

  if ((x < xmin) || (x >= xmax)) {
    f = 0;
  }
  else {
//-----------------------------------------------------------------------------
// interpolate
//-----------------------------------------------------------------------------
    for (int i=0; i<npt; i++) {
      x1 = data[2*i];
      x2 = data[2*i+2];
      if ((x >= x1) && (x<x2)) {
	y1 = data[2*i+1];
	y2 = data[2*i+3];
	
	f = y1+(y2-y1)/(x2-x1)*(x-x1);
	break;
      }
    }
  }

  return f;
}



void plot_all() {

  f_all = new TF1("f_all",baf2_all,100,500,0);

  f_fast = new TF1("f_fast",baf2_fast,100,500,0);

  f_all->Draw();
  f_fast->SetLineColor(4);
  f_fast->Draw("same");
}  
